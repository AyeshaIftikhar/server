const { Assert } = require('../type')
const Name = require('../name')

const hasValue = v => v !== undefined && v !== null
const getPathValue = (p, input) => {
  const aliasName = p.path.map(pp => pp.name).join('_')
  if (input[aliasName] !== undefined) {
    return [input[aliasName]]
  } else {
    const values = p.path.reduce((res, n) => {
      const result = []
      const getValue = (value, name) => {
        if (value !== null) {
          value = value[name]
          result.push(value)
        } else {
          result.push(undefined)
        }
      }
      res.forEach(value => {
        if (value !== undefined) {
          if (Array.isArray(value)) {
            value.forEach(v => getValue(v, n.name))
          } else {
            getValue(value, n.name)
          }
        }
      })
      return result
    }, [input])
    return values.filter(v => v !== undefined)
  }
}
const uniquePathToQuery = ({ paths, input, ignores = [] }) => {
  Assert.validate({ paths, object: input, strings: ignores })
  const keys = paths
    .filter(p => !ignores.includes(
      p.path.map(pp => pp.name).join('.'))
    )
    .map(p => {
      const name = p.path.map(pp => pp.name).join('.')
      const values = getPathValue(p, input)
      if (!values.length) return null
      return {[name]: {$in: values}}
    })
    .filter(p => p !== null)
  if (!keys.length) return Name.FALSE_QUERY
  return { $or: keys}
}
const filterPathToQuery = ({ paths, filter }) => {
  let minorQueries = []
  if (hasValue(filter[Name.FILTER_OPS.AND])) {
    const value = filter[Name.FILTER_OPS.AND]
    const queries = value.map(filter => filterPathToQuery({ paths, filter }))
    if (queries.length) {
      minorQueries.push({ $and: queries })
    }
  }
  if (hasValue(filter[Name.FILTER_OPS.OR])) {
    const value = filter[Name.FILTER_OPS.OR]
    const queries = value.map(filter => filterPathToQuery({ paths, filter }))
    if (queries.length) {
      minorQueries.push({ $or: queries })
    }
  }
  paths.forEach(p => {
    const name = p.path.map(p => p.name).join('.')
    const aliasName = p.path.map(p => p.name).join('_')
    for(let i = 0; i < Name.ALL_FILTER_OPS.length; i++) {
      const op = Name.ALL_FILTER_OPS[i]
      const filterName = op ? `${aliasName}_${op}` : aliasName
      const value = filter[filterName]
      if (value !== undefined) {
        if (value !== null) {
          switch(op) {
            case Name.FILTER_OPS.ARRAY.IN:
              minorQueries.push({
                [name]: { $in: value }
              })
              break
            case Name.FILTER_OPS.ARRAY.NOT_IN:
              minorQueries.push({
                [name]: {$nin: value},
              })
              break
            case Name.FILTER_OPS.COMPARISON.LT:
              minorQueries.push({
                [name]: {$lt: value},
              })
              break
            case Name.FILTER_OPS.COMPARISON.LTE:
              minorQueries.push({
                [name]: {$lte: value},
              })
              break
            case Name.FILTER_OPS.COMPARISON.GT:
              minorQueries.push({
                [name]: {$gt: value},
              })
              break
            case Name.FILTER_OPS.COMPARISON.GTE:
              minorQueries.push({
                [name]: {$gte: value},
              })
              break
            case Name.FILTER_OPS.STRING.CONTAINS:
              minorQueries.push({
                [name]: {$regex: value}
              })
              break
            case Name.FILTER_OPS.STRING.NOT_CONTAINS:
              minorQueries.push({
                [name]: {$regex: `^(?!.*${value}).*$`}
              })
              break
            case Name.FILTER_OPS.STRING.STARTS_WITH:
              minorQueries.push({
                [name]: {$regex: `^${value}`}
              })
              break
            case Name.FILTER_OPS.STRING.NOT_STARTS_WITH:
              minorQueries.push({
                [name]: {$regex: `^(?!${value}).+`}
              })
              break
            case Name.FILTER_OPS.STRING.ENDS_WITH:
              minorQueries.push({
                [name]: {$regex: `${value}$`}
              })
              break
            case Name.FILTER_OPS.STRING.NOT_ENDS_WITH:
              minorQueries.push({
                [name]: {$regex: `.*(?<!${value})$`}
              })
              break
          }
        }
        switch (op) {
          case Name.FILTER_OPS.BASIC.EMPTY:
            minorQueries.push({
              [name]: value,
            })
            break
          case Name.FILTER_OPS.BASIC.NOT:
            minorQueries.push({
              [name]: {$ne: value}
            })
            break
        }
      }
    }
  })
  if (!minorQueries.length) {
    return {}
  } else {
    return { $and: minorQueries }
  }
}

module.exports = {
  uniquePathToQuery,
  filterPathToQuery,
  getPathValue,
  hasValue,
}
