const Kind = require('../kind')
const Name = require('../name')
const { isUniquePath, isOrderPath, isFilterPath } = require('../language/utils')
const { Store } = require('../state')
const {
  uniquePathToQuery,
  filterPathToQuery,
  hasValue,
  getPathValue
} = require('./utils')

module.exports = () => {
  const resolvers = {}
  const { gql: { query, accessList } } = Store.get()
  query.fields.forEach(f => {
    resolvers[f.name] = async(_, input = {}, { collections }) => {
      const method = Name.queryToMethod(f.name)
      switch(method) {
        case Kind.FIND_ONE: {
          const defName = Name.findOneToObjName(f.name)
          const def = accessList.find(d => d.name === defName)
          const collection = collections[defName]
          const query = uniquePathToQuery({
            paths: def.paths.filter(isUniquePath),
            input,
          })
          return await collection.findOne(query)
        }
        case Kind.FIND_MULTIPLE: {
          const defName = Name.findMultipleToObjName(f.name)
          const def = accessList.find(d => d.name === defName)
          const collection = collections[defName]
          const { first, last, before, after, orderBy, filter } = input
          let query = {}
          const order = {}
          if (hasValue(first) && hasValue(last)) {
            throw new Error('first and last can not be used together')
          }
          if (hasValue(filter)) {
            query = filterPathToQuery({
              paths: def.paths.filter(isFilterPath),
              filter,
            })
          }
          const totalCount = await collection.count(query)
          const beforeQuery = { $or: [] }
          const afterQuery = { $or: [] }
          let skip = 0
          let limit = totalCount
          let orderState = null
          if (hasValue(first)) {
            if (first < 0) throw new Error('first cannot be less than zero')
            limit = first
          }
          if (hasValue(last)) {
            if (last < 0) throw new Error('last cannot be less than zero')
            skip = totalCount - last
            if (skip < 0) skip = 0
          }
          if (hasValue(orderBy)) {
            const direction = Name.OPS[Kind.ORDER].reduce(
              (r, n) => new RegExp(`_${n}$`).test(orderBy) ? Name.ORDER_OPS[n] : r,
              0,
            )
            const orderName = Name.OPS[Kind.ORDER].reduce(
              (r, n) => r.replace(new RegExp(`_${n}$`), ''),
              orderBy
            )
            const orderPaths = def.paths.filter(isOrderPath)
            orderPaths.forEach(p => {
              const aliasName = p.path.map(p => p.name).join('_')
              const name = p.path.map(p => p.name).join('.')
              if (aliasName === orderName) {
                order[name] = direction
                orderState = {
                  name,
                  direction,
                  path: p,
                }
              }
            })
          }
          if (hasValue(after)) {
            const node = await collection.findOne({ id: after })
            if (!node) throw new Error('before does not appear to be a valid id')
            if (orderState) {
              const { name, direction, path } = orderState
              const value = getPathValue(path, node)[0]
              afterQuery.$or.push({ [name]: { $eq: value }, _id: {$gt: node._id }})
              switch (direction) {
                case Name.ORDER_OPS.ASC:
                  afterQuery.$or.push({ [name]: { $gt: value } })
                  break
                case Name.ORDER_OPS.DESC:
                  afterQuery.$or.push({ [name]: { $lt: value } })
                  break
              }
            } else {
              afterQuery.$or.push({ _id: {$gt: node._id} })
            }
          }
          if (hasValue(before)) {
            const node = await collection.findOne({ id: before })
            if (!node) throw new Error('before does not appear to be a valid id')
            if (orderState) {
              const { name, direction, path } = orderState
              const value = getPathValue(path, node)[0]
              beforeQuery.$or.push({ [name]: { $eq: value }, _id: {$lt: node._id }})
              switch (direction) {
                case Name.ORDER_OPS.ASC:
                  beforeQuery.$or.push({ [name]: { $lt: value } })
                  break
                case Name.ORDER_OPS.DESC:
                  beforeQuery.$or.push({ [name]: { $gt: value } })
                  break
              }
            } else {
              beforeQuery.$or.push({ _id: {$lt: node._id} })
            }
          }
          if (totalCount === 0) {
            return {
              pageInfo: {
                hasNext: false,
                hasPrev: false,
                start: null,
                end: null,
              },
              nodes: [],
              totalCount,
            }
          }
          order._id = 1
          const firstNode = await collection.find(query).sort(order).limit(1).toArray()
          const lastNode = await collection.find(query).sort(order).skip(totalCount - 1).toArray()
          if (beforeQuery.$or.length) {
            if (!query.$and) query.$and = []
            query.$and.push(beforeQuery)
          }
          if (afterQuery.$or.length) {
            if (!query.$and) query.$and = []
            query.$and.push(afterQuery)
          }
          const nodes = await collection.find(query).sort(order).skip(skip).limit(limit).toArray()
          const start = nodes[0] ? nodes[0].id : null
          const end = nodes[nodes.length - 1] ? nodes[nodes.length - 1].id : null
          const hasNext = lastNode[0].id !== end
          const hasPrev = firstNode[0].id !== start
          return {
            pageInfo: {
              hasNext,
              hasPrev,
              start,
              end,
            },
            nodes,
            totalCount,
          }
        }
      }
    }
  })
  return resolvers
}
