const uuidv4 = require('uuid/v4')
const Kind = require('../kind')
const Name = require('../name')
const { isUniquePath } = require('../language/utils')
const { Store } = require('../state')
const { uniquePathToQuery } = require('./utils')

module.exports = () => {
  const resolvers = {}
  const { gql: { mutation, accessList, genList } } = Store.get()
  mutation.fields.forEach(f => {
    resolvers[f.name] = async(_, {input, id} , { collections }) => {
      const method = Name.mutationToMethod(f.name)
      switch(method) {
        case Kind.CREATION: {
          const defName = Name.creationToObjName(f.name)
          const def = accessList.find(d => d.name === defName)
          const collection = collections[defName]
          const query = uniquePathToQuery({
            paths: def.paths.filter(isUniquePath),
            input,
            ignores: ['id']
          })
          const docs = await collection.find(query).toArray()
          if (docs.length > 0) throw new Error(`input is duplicated`)
          input.id = uuidv4()
          input[Name.FIELD_CREATED_AT] = new Date()
          input[Name.FIELD_UPDATED_AT] = new Date()
          await collection.insert(input)
          return {
            [Name.objToSingularName(defName)]: input,
          }
        }
        case Kind.UPDATE: {
          const defName = Name.updateToObjName(f.name)
          const def = accessList.find(d => d.name === defName)
          const collection = collections[defName]
          const query = uniquePathToQuery({
            paths: def.paths.filter(isUniquePath),
            input,
            ignores: ['id']
          })
          const docs = await collection.find(query).toArray()
          if (docs.length > 0) throw new Error(`input is duplicated`)
          const createInputName = Name.objToCreateInputName(defName)
          const createInputDef = genList.find(d => d.name === createInputName)
          for(let i = 0; i < createInputDef.fields.length; i++) {
            const f = createInputDef.fields[i]
            const value = input[f.name]
            if (value === null) {
              switch(f.type.format) {
                case 'X!':
                case '[X]!':
                case '[X!]!':
                  throw new Error(`${f.name} can not be null`)
                  break
              }
            }
          }
          const id = input.id
          input[Name.FIELD_UPDATED_AT] = new Date()
          await collection.update({ id }, {$set: input})
          return {
            [Name.objToSingularName(defName)]: await collection.findOne({ id }),
          }
        }
        case Kind.DELETE: {
          const defName = Name.deletionToObjName(f.name)
          const collection = collections[defName]
          const doc = await collection.findOne({ id })
          await collection.remove({ id })
          return {
            [Name.objToSingularName(defName)]: doc,
          }
        }
        default:
          throw new Error(`${method} is unexpected value`)
      }
    }
  })
  return resolvers
}
