const { parse } = require('graphql/language')
const Kind = require('../kind')
const {
  defToScalar,
  defToEnum,
  defToUnion,
  defToInterface,
  defToObject,
  defToInput,
  defToExtension,
  defListToMap,
  objToInput,
  buildPath
} = require('./utils')
const { Scalar, Assert } = require('../type')

module.exports = (source, supTypes) => {
  Assert.validate({ string: source, array: supTypes })
  const ast = parse(source)
  const al = []
  const availableTypes = [
    Kind.INT,
    Kind.FLOAT,
    Kind.STRING,
    Kind.BOOLEAN,
    Kind.ID
  ]
  availableTypes.forEach(name => {
    al.push(new Scalar({ name }))
  })
  supTypes.forEach(s => {
    switch (s.kind) {
      case Kind.TYPE_SCALAR:
        al.push(s)
        break
      default:
        throw new Error('Expected sup to have scalar type')
    }
  })

  for(let i = 0; i < ast.definitions.length; i++) {
    const d = ast.definitions[i]
    switch(d.kind) {
      case Kind.SCALAR_TYPE_DEFINITION: {
        al.push(defToScalar(d))
        break
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        al.push(defToEnum(d))
        break
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        al.push(defToInterface(d))
        break
      }
      case Kind.UNION_TYPE_DEFINITION: {
        al.push(defToUnion(d))
        break
      }
      case Kind.OBJECT_TYPE_DEFINITION: {
        al.push(defToObject(d))
        break
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        al.push(defToInput(d))
        break
      }
    }
  }
  ast
    .definitions
    .filter(d => d.kind === Kind.TYPE_EXTENSION_DEFINITION)
    .forEach(d => {
      const extension = defToExtension(d)
      const rootDef = al.find(({ name }) => name === extension.name)
      Assert.validate({ object: rootDef })
      extension.fields.forEach(f => rootDef.addField(f))
    })
  al
    .filter(d => d.kind === Kind.TYPE_OBJECT || d.kind === Kind.TYPE_INPUT)
    .forEach(d => {
      d.addPaths(buildPath(d, al))
    })
  return al
}
