const { Assert } = require('../type')
const { defListToMap } = require('./utils')
const Kind = require('../kind')

const fieldToText = (f) => {
  const argTexts = f.arguments.map(
    arg => `${arg.name}: ${arg.type.format.replace('X', arg.type.name)}`
  )
  if (!argTexts.length) return `  ${f.name}: ${f.type.format.replace('X', f.type.name)}`
  return `  ${f.name}(${argTexts.join(', ')}): ${f.type.format.replace('X', f.type.name)}`
}

const objToText = (def, kind) => {
  const fieldTexts = def.fields.map(fieldToText)
  return [
    `${kind} ${def.name} {`,
    `${fieldTexts.join('\n')}`,
    '}'
  ].join('\n')
}

module.exports = (al, defs) => {
  Assert.validate({ array: [defs, al]})
  const texts = []
  const defMap = defListToMap(al)
  defs.forEach(def => {
    switch(def.kind) {
      case Kind.TYPE_INPUT: {
        texts.push(objToText(def, 'input'))
        break
      }
      case Kind.TYPE_OBJECT: {
        texts.push(objToText(def, 'type'))
        break
      }
      case Kind.TYPE_ENUM: {
        texts.push([
          `enum ${def.name} {`,
          def.values.map(v => `  ${v}`).join('\n'),
          '}'
        ].join('\n'))
        break
      }
      case Kind.TYPE_EXTENSION: {
        let key = 'type'
        if (defMap[def.name]) {
          key = 'extend type'
        }
        texts.push(objToText(def, key))
        break
      }
      case Kind.TYPE_SCALAR:
        texts.push(`scalar ${def.name}`)
        break
      default:
        throw new Error(`Expected ${def.kind} in [Input, Object, Enum, Field, Scalar]`)
        break
    }
  })
  return texts.join('\n')
}
