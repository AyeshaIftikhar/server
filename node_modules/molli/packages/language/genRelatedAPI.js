const Kind = require('../kind')
const Name = require('../name')
const {
  Assert,
  Input,
  Field,
  Obj,
  Enum,
} = require('../type')
const {
  defListToMap,
  objToInput,
  isOrderPath,
  isFilterPath,
  opToFields,
  opToValues,
} = require('./utils')

module.exports = (al, relatedAPIs) => {
  Assert.validate({ array: relatedAPIs })
  const defs = []
  const defMap = defListToMap(al)
  const objMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_OBJECT))
  const modelMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_OBJECT && d.model))
  const unionMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_UNION))
  Object.keys(objMap).forEach(k => defs.push(objToInput(objMap[k], objMap, unionMap)))
  for (let i = 0; i < relatedAPIs.length; i++) {
    const r = relatedAPIs[i]
    switch (r.type) {
      case Kind.CRUD_CREATE_INPUT: {
        const defName = Name.createInputToObjName(r.name)
        const def = defMap[defName]
        const fields = []
        const fieldWithoutUnion = def.fields.filter(f => !unionMap[f.type.name])
        fieldWithoutUnion.forEach(f => {
          const config = {
            name: f.name,
            type: {
              name: f.type.name,
              format: f.type.format,
            }
          }
          if (![Name.FIELD_ID, Name.FIELD_CREATED_AT, Name.FIELD_UPDATED_AT].includes(f.name)) {
            if (objMap[f.type.name]) {
              if (modelMap[f.type.name]) {
                switch(f.type.format) {
                  case 'X':
                  case 'X!':
                    config.name = Name.fieldNameToId(f.name, defName, f.type.name)
                    break
                  case '[X]':
                  case '[X!]':
                  case '[X]!':
                  case '[X!]!':
                    config.name = Name.fieldNameToIds(f.name, defName, f.type.name)
                    break
                }
                config.type.name = Kind.ID
              } else {
                config.type.name = Name.objToInputName(f.type.name)
              }
            }
            fields.push(new Field(config))
          }
        })
        defs.push(new Input({
          name: r.name,
          fields,
        }))
        break
      }
      case Kind.CRUD_CREATE_PAYLOAD: {
        const defName = Name.createPayloadToObjName(r.name)
        const def = defMap[defName]
        defs.push(new Obj({
          name: r.name,
          fields: [
            new Field({
              name: Name.objToSingularName(def.name),
              type: {
                name: def.name,
                format: 'X'
              }
            })
          ]
        }))
        break
      }
      case Kind.CRUD_UPDATE_INPUT: {
        const defName = Name.updateInputToObjName(r.name)
        const def = defMap[defName]
        const fields = []
        const fieldWithoutUnion = def.fields.filter(f => !unionMap[f.type.name])
        fieldWithoutUnion.forEach(f => {
          const config = {
            name: f.name,
            type: {
              name: f.type.name,
              format: f.type.format
            }
          }
          if (![Name.FIELD_CREATED_AT, Name.FIELD_UPDATED_AT].includes(f.name)) {
            if (f.name !== Name.FIELD_ID) {
              config.type.format = f.type.format.replace(/!$/, '')
            }
            if (objMap[f.type.name]) {
              if (modelMap[f.type.name]) {
                switch(f.type.format) {
                  case 'X':
                  case 'X!':
                    config.name = Name.fieldNameToId(f.name, defName, f.type.name)
                    break
                  case '[X]':
                  case '[X!]':
                  case '[X]!':
                  case '[X!]!':
                    config.name = Name.fieldNameToIds(f.name, defName, f.type.name)
                    break
                }
                config.type.name = Kind.ID
              } else {
                config.type.name = Name.objToInputName(f.type.name)
              }
            }
            fields.push(new Field(config))
          }
        })
        defs.push(new Input({
          name: r.name,
          fields,
        }))
        break
      }
      case Kind.CRUD_UPDATE_PAYLOAD: {
        const defName = Name.updatePayloadToObjName(r.name)
        const def = defMap[defName]
        defs.push(new Obj({
          name: r.name,
          fields: [
            new Field({
              name: Name.objToSingularName(def.name),
              type: {
                name: def.name,
                format: 'X'
              }
            })
          ]
        }))
        break
      }
      case Kind.CRUD_DELETE_PAYLOAD: {
        const defName = Name.deletePayloadToObjName(r.name)
        const def = defMap[defName]
        defs.push(new Obj({
          name: r.name,
          fields: [
            new Field({
              name: Name.objToSingularName(def.name),
              type: {
                name: def.name,
                format: 'X'
              }
            })
          ]
        }))
        break
      }
      case Kind.CRUD_ORDER: {
        const defName = Name.orderToObjName(r.name)
        const def = defMap[defName]
        const orderPaths = def.paths.filter(isOrderPath)
        let values = []
        orderPaths.forEach(p => {
          const name = p.path.map(p => p.name).join('_')
          values = values.concat(opToValues(Name.OPS[Kind.ORDER], name))
        })
        defs.push(new Enum({
          name: r.name,
          values,
        }))
        break
      }
      case Kind.CRUD_FILTER: {
        const defName = Name.filterToObjName(r.name)
        const def = defMap[defName]
        const filterPaths = def.paths.filter(isFilterPath)
        let fields = []
        filterPaths.forEach(p => {
          const name = p.path.map(p => p.name).join('_')
          if (p.is.enum) {
            const ops = Name.OPS[Kind.ENUM]
            fields = fields.concat(opToFields(
              ops,
              p.field.type.name,
              name
            ))
          } else {
            const ops = Name.OPS[p.field.type.name]
            if (ops) {
              fields = fields.concat(opToFields(
                ops,
                p.field.type.name,
                name
              ))
            }
          }
        })
        fields = fields.concat([
          new Field({
            name: Name.FILTER_OPS.AND,
            type: {
              name: r.name,
              format: '[X!]'
            },
          }),
          new Field({
            name: Name.FILTER_OPS.OR,
            type: {
              name: r.name,
              format: '[X!]'
            }
          })
        ])
        defs.push(new Input({
          name: r.name,
          fields,
        }))
        break
      }
      case Kind.CRUD_CONNECTION: {
        const defName = Name.connectionToObjName(r.name)
        const def = defMap[defName]
        const connection = new Obj({
          name: r.name,
          fields: [
            new Field({
              name: 'pageInfo',
              type: {
                name: 'PageInfo',
                format: 'X!'
              }
            }),
            new Field({
              name: 'nodes',
              type: {
                name: def.name,
                format: '[X]!'
              }
            }),
            new Field({
              name: 'totalCount',
              type: {
                name: Kind.INT,
                format: 'X!'
              }
            })
          ]
        })
        defs.push(connection)
        break
      }
    }
  }
  const pageInfo = new Obj({
    name: 'PageInfo',
    fields: [
      new Field({
        name: 'end',
        type: {
          name: Kind.ID,
          format: 'X'
        }
      }),
      new Field({
        name: 'start',
        type: {
          name: Kind.ID,
          format: 'X'
        }
      }),
      new Field({
        name: 'hasNext',
        type: {
          name: Kind.BOOLEAN,
          format: 'X!'
        }
      }),
      new Field({
        name: 'hasPrev',
        type: {
          name: Kind.BOOLEAN,
          format: 'X!'
        }
      })
    ]
  })
  defs.push(pageInfo)
  return defs
}
