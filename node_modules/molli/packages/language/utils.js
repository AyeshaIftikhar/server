const pluralize = require('pluralize')
const Kind = require('../kind')
const Name = require('../name')
const {
  Scalar,
  Enum,
  Union,
  Argument,
  Field,
  Interface,
  Obj,
  Input,
  Extension,
  Assert,
  Path,
} = require('../type')

const getDirective = (f, name) => {
  Assert.validate({ array: f.directives })
  const directive = f
    .directives
    .find(di => di.name.value === name)
  if (!directive) return null
  return directive
}

const getTypeFormat = (typeNode) => {
  let namedType = typeNode
  let format = 'X'
  const modifiedTypes = []
  while (
    namedType.kind === Kind.LIST_TYPE ||
    namedType.kind === Kind.NON_NULL_TYPE
  ) {
    modifiedTypes.push(namedType.kind)
    namedType = namedType.type
  }
  for(let i = modifiedTypes.length - 1; i >= 0; i--) {
    const modifiedType = modifiedTypes[i]
    switch(modifiedType) {
      case Kind.LIST_TYPE:
        format = `[${format}]`
        break
      case Kind.NON_NULL_TYPE:
        format = `${format}!`
        break
    }
  }
  return format
}

const getNamedType = (typeNode) => {
  let namedType = typeNode
  while (
    namedType.kind === Kind.LIST_TYPE ||
    namedType.kind === Kind.NON_NULL_TYPE
  ) {
    namedType = namedType.type
  }
  return namedType.name.value
}

const getIsUnique = f => {
  Assert.validate({ array: f.directives })
  const isUniqueDirective = getDirective(f, 'isUnique')
  if (isUniqueDirective) return true
  return null
}

const getModel = f => {
  Assert.validate({ array: f.directives })
  const modelDirective = getDirective(f, 'model')
  if (modelDirective) return true
  return false
}

const defToScalar = d => new Scalar({
  name: d.name.value,
})

const defToEnum = d => {
  Assert.validate({ array: d.values })
  const values = d.values.map(v => v.name.value)
  return new Enum({
    name: d.name.value,
    values,
  })
}

const defToUnion = d => {
  Assert.validate({ array: d.types })
  const types = d.types.map(t => t.name.value)
  return new Union({
    name: d.name.value,
    types,
  })
}

const defToField = d => {
  Assert.validate({ array: d.fields })
  const fields = d.fields
    .filter(f => {
      if (f.arguments) {
        return !f.arguments.length
      }
      return true
    })
    .map(f => {
      const field = new Field({
        name: f.name.value,
        type: {
          name: getNamedType(f.type),
          format: getTypeFormat(f.type),
        },
        isUnique: getIsUnique(f),
      })
      return field
    })
  return fields
}

const defToInterface = d => {
  Assert.validate({ array: d.fields })
  const fields = defToField(d)
  return new Interface({
    name: d.name.value,
    fields,
  })
}

const defToObject = d => {
  const fields = defToField(d)
  const model = getModel(d)
  return new Obj({
    name: d.name.value,
    fields,
    model,
    interfaces: d.interfaces.map(inf => inf.name.value),
  })
}

const defToExtension = d => {
  const def = d.definition
  const fields = defToField(def)
  return new Extension({
    name: def.name.value,
    fields,
    model: getModel(def),
    interfaces: def.interfaces.map(inf => inf.name.value),
  })
}

const defToInput = d => {
  Assert.validate({ array: d.fields })
  const fields = defToField(d)
  return new Input({
    name: d.name.value,
    fields,
  })
}

const defListToMap = list => {
  Assert.validate({ array: list })
  return list.reduce((result, next) => {
    result[next.name] = next
    return result
  }, {})
}

const buildPath = (d, al) => {
  Assert.validate({ array: al, object: d })
  let defMap = {}
  const modelMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_OBJECT && d.model))
  const enumMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_ENUM))
  const scalarMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_SCALAR))
  const unionMap = defListToMap(al.filter(d => d.kind === Kind.TYPE_UNION))
  switch (d.kind) {
    case Kind.TYPE_OBJECT:
      defMap = defListToMap(
        al.filter(d => d.kind === Kind.TYPE_OBJECT)
      )
      break
    case Kind.TYPE_INPUT:
      defMap = defListToMap(
        al.filter(d => d.kind === Kind.TYPE_INPUT)
      )
      break
    default:
      throw new Error(`${def.kind} is unexpected value`)
  }
  const paths = []
  const tempPaths = [
    new Path({
      pass: {
        model: false,
        array: false,
        null: false,
      },
      is: {
        enum: false,
        union: false,
        scalar: false,
        loop: false,
      },
      field: new Field({
        name: 'root',
        type: {
          name: d.name,
          format: 'X!',
        }
      })
    })
  ]
  while (tempPaths.length > 0) {
    const {
      path,
      field,
      defs,
      pass,
      is,
    } = tempPaths.pop()
    const d = defMap[field.type.name]
    d.fields.forEach(f => {
      const config = {
        field: f,
        defs: defs.concat([d]),
        path: path.concat([f]),
        pass: {
          model: pass.model,
          array: pass.array,
          null: pass.null,
        },
        is: {
          scalar: is.scalar,
          enum: is.enum,
          union: is.union,
        }
      }
      switch (f.type.format) {
        case 'X':
        case '[X]':
        case '[X]!':
          config.pass.null = true
          break
      }
      switch (f.type.format) {
        case '[X]':
        case '[X!]':
        case '[X]!':
        case '[X!]!':
          config.pass.array = true
          break
      }
      if (defMap[f.type.name] && !defListToMap(config.defs)[f.type.name]) {
        if (modelMap[f.type.name]) {
          config.pass.model = true
        }
        tempPaths.push(new Path(config))
      } else {
        if (defMap[f.type.name]) {
          config.is.loop = true
        }
        if (scalarMap[f.type.name]) {
          config.is.scalar = true
        }
        if (enumMap[f.type.name]) {
          config.is.enum = true
        }
        if (unionMap[f.type.name]) {
          config.is.union = true
        }
        paths.push(new Path(config))
      }
    })
  }
  return paths
}

const objToInput = (obj, objectMap, unionMap) => {
  Assert.validate({ objects: [obj, objectMap, unionMap] })
  const fields = []
  const fieldWithoutUnion = obj.fields.filter(f => !unionMap[f.type.name])
  fieldWithoutUnion.forEach(f => {
    let field = null
    if (objectMap[f.type.name]) {
      field = new Field({
        name: f.name,
        type: {
          name: Name.objToInputName(f.type.name),
          format: f.type.format
        }
      })
    } else {
      field = new Field({
        name: f.name,
        type: {
          name: f.type.name,
          format: f.type.format
        },
      })
    }
    fields.push(field)
  })
  return new Input({
    name: Name.objToInputName(obj.name),
    fields,
  })
}

const opToValues = (ops, name) => {
  Assert.validate({ strings: ops.concat([name])})
  return ops.map(op => `${name}_${op}`)
}

const opToFields = (ops, typeName, fieldName) => {
  Assert.validate({ strings: [typeName, fieldName].concat(ops)})
  return ops.map(op => {
    const name = op ? `${fieldName}_${op}` : fieldName
    return new Field({
      name,
      type: {
        name: typeName,
        format: /_in$/.test(name) ? '[X!]' : 'X'
      }
    })
  })
}

const isOrderPath = p =>
  !p.pass.array &&
  !p.pass.model &&
  (p.is.enum || p.is.scalar)

const isUniquePath = p =>
  p.field.isUnique &&
  !p.pass.model &&
  (p.is.enum || p.is.scalar)

const isFilterPath = p =>
  !p.pass.model &&
  (p.is.enum || p.is.scalar)


module.exports = {
  getNamedType,
  getTypeFormat,
  defToScalar,
  defToEnum,
  defToUnion,
  defToInterface,
  defToObject,
  defToInput,
  defToExtension,
  defListToMap,
  buildPath,
  objToInput,
  isUniquePath,
  isOrderPath,
  isFilterPath,
  opToFields,
  opToValues,
}
