const buildAL = require('../../packages/language/buildAL')
const supTypes = require('../../packages/language/supTypes')
const expect = require('chai').expect

describe('Language', () => {
  describe('build Path', () => {
    it('should build correct path', () => {
      const source = `
        scalar IMAGE_URL
        scalar VIDEO_URL
        union URL = IMAGE_URL | VIDEO_URL
        enum PASSED {
          TRUE
          FALSE
        }
        type Profile {
          name: String!
          gender: String!
          pass: PASSED!
          url: URL
        }
        type Loc {
          lat: Float!
          lng: Float!
        }
        type Book @model {
          id: ID! @isUnique
        }
        type User @model {
          id: ID! @isUnique
          username: String!
          password: String!
          profile: Profile
          loc: [Loc!]!
          book: Book
          user: User
        }
      `
      const al = buildAL(source, supTypes)
      const user = al.find(d => d.name === 'User')
      const pathName = [
        'User.id',
        'User.username',
        'User.password',
        'User.profile.name',
        'User.profile.gender',
        'User.loc.lat',
        'User.loc.lng',
        'User.book.id',
        'User.user'
      ]
      user.paths.forEach(p => {
        const name = p.path.map(p => p.name).join('.')
        const fullName = `${user.name}.${name}`
        switch(fullName) {
          case 'User.id':
          case 'User.username':
          case 'User.password':
            expect(p.is).to.include({
              scalar: true,
              enum: false,
              union: false,
              loop: false,
            })
            expect(p.pass).to.include({
              model: false,
              null: false,
              array: false,
            })
            break
          case 'User.profile.name':
          case 'User.profile.gender':
            expect(p.is).to.include({
              scalar: true,
              enum: false,
              union: false,
              loop: false,
            })
            expect(p.pass).to.include({
              null: true,
              model: false,
              array: false,
            })
            break
          case 'User.profile.pass':
            expect(p.is).to.include({
              scalar: false,
              union: false,
              enum: true,
              loop: false,
            })
            expect(p.pass).to.include({
              null: true,
              model: false,
              array: false
            })
            break
          case 'User.profile.url':
            expect(p.is).to.include({
              scalar: false,
              union: true,
              enum: false,
              loop: false,
            })
            expect(p.pass).to.include({
              null: true,
              model: false,
              array: false
            })
            break
          case 'User.loc.lat':
          case 'User.loc.lng':
            expect(p.is).to.include({
              scalar: true,
              enum: false,
              union: false,
              loop: false,
            })
            expect(p.pass).to.include({
              model: false,
              array: true,
              null: false,
            })
            break
          case 'User.user':
            expect(p.is).to.include({
              scalar: false,
              enum: false,
              union: false,
              loop: true,
            })
            expect(p.pass).to.include({
              model: false,
              array: false,
              null: true,
            })
            break
          case 'User.book.id':
            expect(p.is).to.include({
              scalar: true,
              enum: false,
              union: false,
              loop: false,
            })
            expect(p.pass).to.include({
              model: true,
              array: false,
              null: true,
            })
            break
        }
      })
    })
  })
  describe('1 model', () => {
    it('should find model', () => {
      const source = `
        scalar IMAGE_URL
        scalar VIDEO_URL
        enum Gender {
          MALE
          FEMALE
        }
        union URL = IMAGE_URL | VIDEO_URL
        input ProfileInput {
          name: String!
          gender: Gender!
        }
        type Profile {
          name: String!
          gender: Gender!
        }
        type User @model {
          id: ID! @isUnique
          username: String! @isUnique
          ref: URL
        }
        extend type User {
          count: Int!
        }
        type Mutation {
          user(id: ID!): User!
          users: [User!]!
        }
        type Query {
          user(id: ID!): User
          users: [User!]!
        }
      `
      const al = buildAL(source, supTypes)
      const mutation = al.find(d => d.name === 'Mutation')
      const query = al.find(d => d.name === 'Query')
      const user = al.find(d => d.name === 'User')
      const models = al.filter(d => d.model)
      expect(user.fields.length).to.equal(4)
      // find model
      expect(models.length).to.equal(1)
      // merge with extend
      expect(al.length).to.equal(15)
      // filter fields having arguments
      expect(mutation.fields.length).to.equal(1)
      expect(query.fields.length).to.equal(1)
    })
  })
})
