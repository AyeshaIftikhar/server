const buildAL = require('../../packages/language/buildAL')
const supTypes = require('../../packages/language/supTypes')
const genSupAPI = require('../../packages/language/genSupAPI')
const genRelatedAPI = require('../../packages/language/genRelatedAPI')
const format = require('../../packages/language/format')
const expect = require('chai').expect
const basicContent = `
  type Profile {
    name: String! @isUnique
    gender: String!
  }
  type User @model {
    id: ID! @isUnique
    profile: [Profile]
  }
  type Query {
    version: String
  }
`
const advancedContent = `
  scalar IMAGE_URL
  scalar VIDEO_URL
  union URL = IMAGE_URL | VIDEO_URL
  enum Gender {
    MALE
    FEMALE
  }
  type Profile {
    name: String! @isUnique
    gender: Gender!
    age: Int
    count: Float
    banned: Boolean
    createdAt: Date
  }
  type Book @model {
    id: ID @isUnique
    title: String
  }
  type User @model {
    id: ID! @isUnique
    profile: Profile
    user: User
    book: Book
    books: [Book!]!
    findBook(id: ID!): Book!
    url: URL
  }
`
const accessList = buildAL(advancedContent, supTypes)
const { mutation, query, timeDefs, relatedAPIs } = genSupAPI(accessList)
const defs = genRelatedAPI(accessList, relatedAPIs)

describe('Generate API', () => {
  it('should generate CreateInput', () => {
    const createUserInput = defs.find(d => d.name == 'CreateUserInput')
    const genCreateUserText = format(accessList, [createUserInput])
    const expectedCreateUserOutput = [
      'input CreateUserInput {',
      '  profile: ProfileInput',
      '  userId: ID',
      '  bookId: ID',
      '  bookIds: [ID!]!',
      '}'
    ].join('\n')
    expect(genCreateUserText).to.equal(expectedCreateUserOutput)
  })
  it('should generate UpdateInput', () => {
    const updateUserInput = defs.find(d => d.name == 'UpdateUserInput')
    const genUpdateUserText = format(accessList, [updateUserInput])
    const expectedUpdateUserOutput = [
      'input UpdateUserInput {',
      '  id: ID!',
      '  profile: ProfileInput',
      '  userId: ID',
      '  bookId: ID',
      '  bookIds: [ID!]',
      '}'
    ].join('\n')
    expect(genUpdateUserText).to.equal(expectedUpdateUserOutput)
  })
  it('should generate CreatePayload', () => {
    const createUserPayload = defs.find(d => d.name === 'CreateUserPayload')
    const genCreateUserPayloadText = format(accessList, [createUserPayload])
    const expectedCreateUserPayload = [
      'type CreateUserPayload {',
      '  user: User',
      '}'
    ].join('\n')
    expect(genCreateUserPayloadText).to.equal(expectedCreateUserPayload)
  })
  it('should generate UpdatePayload', () => {
    const updateUserPayload = defs.find(d => d.name === 'UpdateUserPayload')
    const genUpdateUserPayloadText = format(accessList, [updateUserPayload])
    const expectedUpdateUserPayload = [
      'type UpdateUserPayload {',
      '  user: User',
      '}'
    ].join('\n')
    expect(genUpdateUserPayloadText).to.equal(expectedUpdateUserPayload)
  })
  it('should generate DeletePayload', () => {
    const deleteUserPayload = defs.find(d => d.name === 'DeleteUserPayload')
    const genDeleteUserPayloadText = format(accessList, [deleteUserPayload])
    const expectedDeleteUserPayload = [
      'type DeleteUserPayload {',
      '  user: User',
      '}'
    ].join('\n')
    expect(genDeleteUserPayloadText).to.equal(expectedDeleteUserPayload)
  })
  it('should generate PageInfo', () => {
    const pageInfo = defs.find(d => d.name === 'PageInfo')
    const genPageInfoText = format(accessList, [pageInfo])
    const expectedPageInfoOutput = [
      'type PageInfo {',
      '  end: ID',
      '  start: ID',
      '  hasNext: Boolean!',
      '  hasPrev: Boolean!',
      '}'
    ].join('\n')
    expect(genPageInfoText).to.equal(expectedPageInfoOutput)
  })
  it('should generate Connection', () => {
    const userConnection = defs.find(d => d.name === 'UserConnection')
    const genUserConnectionText = format(accessList, [userConnection])
    const expectedUserConnectionOutput = [
      'type UserConnection {',
      '  pageInfo: PageInfo!',
      '  nodes: [User]!',
      '  totalCount: Int!',
      '}'
    ].join('\n')
    expect(genUserConnectionText).to.equal(expectedUserConnectionOutput)
  })
  it('should generate Order', () => {
    const userOrder = defs.find(d => d.name === 'UserOrderBy')
    const genUserOrderText = format(accessList, [userOrder])
    const expectedUserOrderOutput = [
      'enum UserOrderBy {',
      '  id_ASC',
      '  id_DESC',
      '  profile_name_ASC',
      '  profile_name_DESC',
      '  profile_gender_ASC',
      '  profile_gender_DESC',
      '  profile_age_ASC',
      '  profile_age_DESC',
      '  profile_count_ASC',
      '  profile_count_DESC',
      '  profile_banned_ASC',
      '  profile_banned_DESC',
      '  profile_createdAt_ASC',
      '  profile_createdAt_DESC',
      '}'
    ].join('\n')
    expect(genUserOrderText).to.equal(expectedUserOrderOutput)
  })
  it('should generate Filter', () => {
    const userFilter = defs.find(d => d.name === 'UserFilter')
    const genUserFilterText = format(accessList, [userFilter])
    const expectedUserFilterOutput = [
      'input UserFilter {',
      '  id: ID',
      '  id_not: ID',
      '  id_in: [ID!]',
      '  id_not_in: [ID!]',
      '  id_lt: ID',
      '  id_lte: ID',
      '  id_gt: ID',
      '  id_gte: ID',
      '  id_contains: ID',
      '  id_not_contains: ID',
      '  id_starts_with: ID',
      '  id_not_starts_with: ID',
      '  id_ends_with: ID',
      '  id_not_ends_with: ID',
      '  profile_name: String',
      '  profile_name_not: String',
      '  profile_name_in: [String!]',
      '  profile_name_not_in: [String!]',
      '  profile_name_lt: String',
      '  profile_name_lte: String',
      '  profile_name_gt: String',
      '  profile_name_gte: String',
      '  profile_name_contains: String',
      '  profile_name_not_contains: String',
      '  profile_name_starts_with: String',
      '  profile_name_not_starts_with: String',
      '  profile_name_ends_with: String',
      '  profile_name_not_ends_with: String',
      '  profile_gender: Gender',
      '  profile_gender_not: Gender',
      '  profile_gender_in: [Gender!]',
      '  profile_gender_not_in: [Gender!]',
      '  profile_age: Int',
      '  profile_age_not: Int',
      '  profile_age_in: [Int!]',
      '  profile_age_not_in: [Int!]',
      '  profile_age_lt: Int',
      '  profile_age_lte: Int',
      '  profile_age_gt: Int',
      '  profile_age_gte: Int',
      '  profile_count: Float',
      '  profile_count_not: Float',
      '  profile_count_in: [Float!]',
      '  profile_count_not_in: [Float!]',
      '  profile_count_lt: Float',
      '  profile_count_lte: Float',
      '  profile_count_gt: Float',
      '  profile_count_gte: Float',
      '  profile_banned: Boolean',
      '  profile_banned_not: Boolean',
      '  profile_createdAt: Date',
      '  profile_createdAt_not: Date',
      '  profile_createdAt_in: [Date!]',
      '  profile_createdAt_not_in: [Date!]',
      '  profile_createdAt_lt: Date',
      '  profile_createdAt_lte: Date',
      '  profile_createdAt_gt: Date',
      '  profile_createdAt_gte: Date',
      '  AND: [UserFilter!]',
      '  OR: [UserFilter!]',
      '}'
    ].join('\n')
    expect(genUserFilterText).to.equal(expectedUserFilterOutput)
  })
  it('should generate createdAt, updatedAt', () => {
    const content = `
      type User @model {
        id: ID!
      }
    `
    const accessList = buildAL(content, supTypes)
    const { timeDefs, relatedAPIs } = genSupAPI(accessList)
    const defs = genRelatedAPI(accessList, relatedAPIs)
    const genText = format(accessList, timeDefs)
    const expectedOutput = [
      'extend type User {',
      '  createdAt: Date!',
      '  updatedAt: Date!',
      '}'
    ]
    expect(genText).to.equal(expectedOutput.join('\n'))
  })
  it('should generate query, mutation', () => {
    const accessList = buildAL(basicContent, supTypes)
    const { query , mutation } = genSupAPI(accessList)
    const genQueryText = format(accessList, [query])
    const genMutationText = format(accessList, [mutation])
    const queryOutput = [
      'extend type Query {',
      '  users(first: Int, last: Int, before: String, after: String, orderBy: UserOrderBy, filter: UserFilter): UserConnection!',
      '  user(id: ID, profile_name: String): User',
      '}',
    ].join('\n')
    const mutationOutput = [
      'type Mutation {',
      '  createUser(input: CreateUserInput!): CreateUserPayload!',
      '  updateUser(input: UpdateUserInput!): UpdateUserPayload!',
      '  deleteUser(id: ID!): DeleteUserPayload!',
      '}'
    ].join('\n')
    expect(genQueryText).to.equal(queryOutput)
    expect(genMutationText).to.equal(mutationOutput)
  })
})
